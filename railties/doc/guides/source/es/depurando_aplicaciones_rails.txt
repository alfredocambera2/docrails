Depurando Aplicaciones Rails
============================
 
Esta guía le introducirá a las técnicas de depuración para aplicaciones Ruby on Rails. Empleando esta guía estará en la capacidad de:

* Comprender el propósito de depurar.
* Identificar fallos y problemas en la aplicación que las pruebas (test) no están identificaando.
* Aprender las diferentes formas de depurar
* Analizar la pila de instrucciones (stack trace)

== Examinar Ayudantes (Helpers) para la Depuración

Una tarea común es inspeccionar el contenido de una variable. En Rails, esto se puede hacer empleando tres métodos:

* `debug`
* `to_yaml`
* `inspect`

=== debug

El ayudante `debug` regresará una etiqueta <pre> que generara el objeto empleando el formato YAML. Esto generará datos que pueden ser leidos por los humanos a partir de cualquier objeto. Por ejemplo, si tiene el siguiente código en una vista:

[source, html]
----------------------------------------------------------------------------
<%= debug @post %>
<p>
  <b>Title:</b>
  <%=h @post.title %>
</p>
----------------------------------------------------------------------------

Verá algo como lo siguiente:

[source, log]
----------------------------------------------------------------------------
--- !ruby/object:Post
attributes:
  updated_at: 2008-09-05 22:55:47
  body: It's a very helpful guide for debugging your Rails app.
  title: Rails debugging guide
  published: t
  id: "1"
  created_at: 2008-09-05 22:55:47
attributes_cache: {}


Title: Rails debugging guide
----------------------------------------------------------------------------

=== to_yaml

Mostrar una variable de instancia, cualquier otro objeto o método en formato YAML se puede lograr de la siguiente manera: 

[source, html]
----------------------------------------------------------------------------
<%= simple_format @post.to_yaml %>
<p>
  <b>Title:</b>
  <%=h @post.title %>
</p>
----------------------------------------------------------------------------

El método  `to_yaml` convierte el método a formato WAML, haciendolo más legible, luego se usa el ayudante `simple_format` para generar cada linea como en la consola. Así es como el método `debug` hace su mágia.

Como resultado de ello, tendrá algo como siguiente en su vista (view):

[source, log]
----------------------------------------------------------------------------
--- !ruby/object:Post
attributes:
updated_at: 2008-09-05 22:55:47
body: It's a very helpful guide for debugging your Rails app.
title: Rails debugging guide
published: t
id: "1"
created_at: 2008-09-05 22:55:47
attributes_cache: {}

Title: Rails debugging guide
----------------------------------------------------------------------------

=== inspect

Otro método útil para mostrar los valores de un objeto es `inspect`, especialmente cuando se trabaja con arreglos y hashes. Lo siguiente mostrará el valir del objeto como una cadena. Por ejemplo:

[source, html]
----------------------------------------------------------------------------
<%= [1, 2, 3, 4, 5].inspect %>
<p>
  <b>Title:</b>
  <%=h @post.title %>
</p>
----------------------------------------------------------------------------

Generará algo como lo siguiente:

[source, log]
----------------------------------------------------------------------------
[1, 2, 3, 4, 5]

Title: Rails debugging guide
----------------------------------------------------------------------------

== The Logger

Támbien puede ser util para almacenar información en los archivos de bitácora en tiempo de ejecución. Rails mantiene archivos de bitácoras separados para cada entorno de ejecución.

=== Ques es el Logger?

Rails hace uso del gestor de bitácoras estándar de Ruby,`logger`, para escribir información. El mismo, puede ser reemplazado por otras opciones como `Log4R` si lo desea.

Se puede especificar un gestor de bitácoras alternativo en el archivo +environment.rb+ o en cualquier archivo del entorno:

[source, ruby]
----------------------------------------------------------------------------
ActiveRecord::Base.logger = Logger.new(STDOUT)
ActiveRecord::Base.logger = Log4r::Logger.new("Application Log")
----------------------------------------------------------------------------

O en la sección +Initializer+, agregue _cualquiera_ de los siguientes:

[source, ruby]
----------------------------------------------------------------------------
config.logger = Logger.new(STDOUT)
config.logger = Log4r::Logger.new("Application Log")
----------------------------------------------------------------------------

[NOTA]
Por defecto, cada archivo de bitácora es creado bajo `RAILS_ROOT/log/`, donde el nombre del archivo es +entorno_nombre.log+.

=== Niveles de Bitácoras

Cuando algo es registrado, se envia al archivo correspondiente si el nivel de bitácora del mensaje es mayor o igual que el que se encuentra configurado. Si quiere saber el nivel de bitácora actual, puede llamar al método `ActiveRecord::Base.logger.level`.

Los niveles de las bitácoras son: +:debug+, +:info+, +:warn+, +:error+, y +:fatal+, que as su vez corresponde con niveles que van desde el 0 al 4, respectivamente. Para cambiar el nivel de las bitácoras por defecto:

[source, ruby]
----------------------------------------------------------------------------
config.log_level = Logger::WARN # In any environment initializer, or
ActiveRecord::Base.logger.level = 0 # at any time
----------------------------------------------------------------------------

Esto es útil cuando se quiere hacer seguimiento a las bitácoras en los ambientes de desarrollo (development) ó pre-producción (staging), pero no se quiere inundar las bitácoras de producción con información innecesaria.

[NOTA]
El nivel de bitácoras por defecto en Rails es +info+ para el ambiente de producción, y +debug+ para los ambientes de desarrollo y pruebas (testing).

=== Enviando Mensajes 

Para escribir en el archivo de bitácoras actual use el método `logger.(debug|info|warn|error|fatal)` desde dentro del controlodor, model o mensajero de correos (mailer):

[source, ruby]
----------------------------------------------------------------------------
logger.debug "Person attributes hash: #{@person.attributes.inspect}"
logger.info "Processing the request..."
logger.fatal "Terminating application, raised unrecoverable error!!!"
----------------------------------------------------------------------------

Aquí hay un ejemplo de un método implementado con niveles de bitácora adicionales:

[source, ruby]
----------------------------------------------------------------------------
class PostsController < ApplicationController
  # ...

  def create
    @post = Post.new(params[:post])
    logger.debug "New post: #{@post.attributes.inspect}"
    logger.debug "Post should be valid: #{@post.valid?}"

    if @post.save
      flash[:notice] = 'Post was successfully created.'
      logger.debug "The post was saved and now is the user is going to be redirected..."
      redirect_to(@post)
    else
      render :action => "new"
    end
  end

  # ...
end
----------------------------------------------------------------------------

Este es un ejemplo del texto generado por este método:

[source, log]
----------------------------------------------------------------------------
Processing PostsController#create (for 127.0.0.1 at 2008-09-08 11:52:54) [POST]
  Session ID: BAh7BzoMY3NyZl9pZCIlMDY5MWU1M2I1ZDRjODBlMzkyMWI1OTg2NWQyNzViZjYiCmZsYXNoSUM6J0FjdGl
vbkNvbnRyb2xsZXI6OkZsYXNoOjpGbGFzaEhhc2h7AAY6CkB1c2VkewA=--b18cd92fba90eacf8137e5f6b3b06c4d724596a4
  Parameters: {"commit"=>"Create", "post"=>{"title"=>"Debugging Rails", 
 "body"=>"I'm learning how to print in logs!!!", "published"=>"0"}, 
 "authenticity_token"=>"2059c1286e93402e389127b1153204e0d1e275dd", "action"=>"create", "controller"=>"posts"}
New post: {"updated_at"=>nil, "title"=>"Debugging Rails", "body"=>"I'm learning how to print in logs!!!", 
 "published"=>false, "created_at"=>nil}
Post should be valid: true
  Post Create (0.000443)   INSERT INTO "posts" ("updated_at", "title", "body", "published", 
 "created_at") VALUES('2008-09-08 14:52:54', 'Debugging Rails', 
 'I''m learning how to print in logs!!!', 'f', '2008-09-08 14:52:54')
The post was saved and now is the user is going to be redirected...
Redirected to #<Post:0x20af760>
Completed in 0.01224 (81 reqs/sec) | DB: 0.00044 (3%) | 302 Found [http://localhost/posts]
----------------------------------------------------------------------------

Agregar niveles adicionales de bitácora como este facilita la búsqueda de conducta inusual en sus logs. Toda vez que se implemente, se hará necesario asegurarse de hacer uso adecuado de los mismos, para evitar llenar las bitácoras del ambiente de producción con información inútil.

== Depurando con ruby-debug

Cuando su código se comporta de manera inesperada, puede intentar enviar información a lás bitácoras o a la consola para diagnosticar el fallo. Desarfortunadamente, hay muchas ocasiones en la que este tipo de estrxiategia no permite encontrar la raíz del problema. Cuando se requiere examinar el código fuente, el depurador será su mejor aliado.

El depurador puede ayudarle si quiere aprender sobre el código fuente de Rails pero no sabe por donde empezar. Solo depure cualquier solicitud que le reciba en un aplicación y utilice esta guía para aprender como ir desde el código que ha escrito hacia las profundidades del código en Rails.

=== Setup

El depurador empleado por Rails, +ruby-debug+, viene como una gema. Para instalarlo ejecute la siguiente secuencia de comandos: 

[source, shell]
----------------------------------------------------------------------------
$ sudo gem install ruby-debug
----------------------------------------------------------------------------

En el caso de que quiera descargar una versión en particular o obtener el código fuente, consulte link:http://rubyforge.org/projects/ruby-debug/[project's page on rubyforge].

Rails cuaenta con soporte integrado para ruby-debug desde Rails 2.0. Dentro de cualquier aplicación Rails se puede invocar el depurador mediante una llamada al método `debugger`.

Aquí hay un ejemplo:

[source, ruby]
----------------------------------------------------------------------------
class PeopleController < ApplicationController
  def new
    debugger
    @person = Person.new
  end
end
----------------------------------------------------------------------------

Si ve el siguiente mensane en la consola o en las bitácoras:

[source, log]
----------------------------------------------------------------------------
***** Debugger requested, but was not available: Start server with --debugger to enable *****
----------------------------------------------------------------------------

Asegurese de que ha iniciado el servidor Web con la opción +--debugger+:

[source, shell]
----------------------------------------------------------------------------
~/PathTo/rails_project$ script/server --debugger
=> Booting Mongrel (use 'script/server webrick' to force WEBrick)
=> Rails 2.2.0 application starting on http://0.0.0.0:3000
=> Debugger enabled
...
----------------------------------------------------------------------------

[NOTA]
En el modo desarrollo, puede hacer lo siguiente de manera dinámica: `require \'ruby-debug\'`, en vez de reiniciar el servidor, en caso de no haberlo iniciado con la opción `--debugger`.

Para usar la depuración en Rails, necesitará estar ejecuando su aplicación sobre *WEBrick* o *Mongrel*. Por el momento no existe soporte para servidores alternativos.

=== La Consola

Tan pronto como su aplicación llama al método `debugger`, el depurador se iniciará en una consola para depuración dentro de la ventana desde cual se está ejecutando el servidor de aplicaciones, luego de lo cual encontrará en el interprete de comandos de ruby-debug `(rdb:n)`. La _n_ indica el número de hilos. El interprete le montrará la siguiente linea de código que se encuentra pendiente por ejecutar.

Si llegó allí por una petición desde el navegador, la pestaña (tab) que envió la petición permanecerá en espera hasta que el depurador haya terminado y se haya completado la traza para completar el procesamiento de la petición.

Por ejemplo:

----------------------------------------------------------------------------
@posts = Post.find(:all)
(rdb:7)
----------------------------------------------------------------------------

Ahora llegó el momento de jugar y examinar su aplicación. U buen lugar para empezar es solicitandole ayuda al depurador... con el comando: `help` (No la viste venir, ¿cierto?)

----------------------------------------------------------------------------
(rdb:7) help
ruby-debug help v0.10.2
Type 'help <command-name>' for help on a specific command

Available commands:
backtrace  delete   enable  help    next  quit     show    trace
break      disable  eval    info    p     reload   source  undisplay
catch      display  exit    irb     pp    restart  step    up
condition  down     finish  list    ps    save     thread  var
continue   edit     frame   method  putl  set      tmate   where
----------------------------------------------------------------------------

[NOTA]
Para ver el menu de ayuda de cualquier comando: `help <command-name>` con el modo de depuración activo. Por ejemplo: _+help var+_

El sigueinte comando que aprederá es uno de los más útiles: `list`. Adicionalmente, se pueden abreviar comandos de ruby-debug siempre y cuando se provean suficientes comandos para distinguirlos de otros ya existentes, así por ejemplo podría usar +l+ para el comando +list+.

This command shows you where you are in the code by printing 10 lines centered around the current line; the current line in this particular case is line 6 and is marked by +=>+.

----------------------------------------------------------------------------
(rdb:7) list
[1, 10] in /PathToProject/posts_controller.rb
   1  class PostsController < ApplicationController
   2    # GET /posts
   3    # GET /posts.xml
   4    def index
   5      debugger
=> 6      @posts = Post.find(:all)
   7
   8      respond_to do |format|
   9        format.html # index.html.erb
   10        format.xml  { render :xml => @posts }
----------------------------------------------------------------------------

If you repeat the +list+ command, this time using just `l`, the next ten lines of the file will be printed out.

----------------------------------------------------------------------------
(rdb:7) l
[11, 20] in /PathTo/project/app/controllers/posts_controller.rb
   11      end
   12    end
   13
   14    # GET /posts/1
   15    # GET /posts/1.xml
   16    def show
   17      @post = Post.find(params[:id])
   18
   19      respond_to do |format|
   20        format.html # show.html.erb
----------------------------------------------------------------------------

And so on until the end of the current file. When the end of file is reached, the +list+ command will start again from the beginning of the file and continue again up to the end, treating the file as a circular buffer.

=== The Context

When you start debugging your application, you will be placed in different contexts as you go through the different parts of the stack.

ruby-debug creates a content when a stopping point or an event is reached. The context has information about the suspended program which enables a debugger to inspect the frame stack, evaluate variables from the perspective of the debugged program, and contains information about the place where the debugged program is stopped.

At any time you can call the `backtrace` command (or its alias `where`) to print the backtrace of the application. This can be very helpful to know how you got where you are. If you ever wondered about how you got somewhere in your code, then `backtrace` will supply the answer.

----------------------------------------------------------------------------
(rdb:5) where
    #0 PostsController.index
       at line /PathTo/project/app/controllers/posts_controller.rb:6
    #1 Kernel.send
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/base.rb:1175
    #2 ActionController::Base.perform_action_without_filters
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/base.rb:1175
    #3 ActionController::Filters::InstanceMethods.call_filters(chain#ActionController::Fil...,...)
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/filters.rb:617
...
----------------------------------------------------------------------------

You move anywhere you want in this trace (thus changing the context) by using the `frame _n_` command, where _n_ is the specified frame number.

----------------------------------------------------------------------------
(rdb:5) frame 2
#2 ActionController::Base.perform_action_without_filters
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/base.rb:1175
----------------------------------------------------------------------------

The available variables are the same as if you were running the code line by line. After all, that's what debugging is.

Moving up and down the stack frame: You can use `up [n]` (`u` for abbreviated) and `down [n]` commands in order to change the context _n_ frames up or down the stack respectively. _n_ defaults to one. Up in this case is towards higher-numbered stack frames, and down is towards lower-numbered stack frames.

=== Threads

The debugger can list, stop, resume and switch between running threads by using the command `thread` (or the abbreviated `th`). This command has a handful of options:

* `thread` shows the current thread.
* `thread list` is used to list all threads and their statuses. The plus + character and the number indicates the current thread of execution.
* `thread stop _n_` stop thread _n_.
* `thread resume _n_` resumes thread _n_.
* `thread switch _n_` switches the current thread context to _n_.

This command is very helpful, among other occasions, when you are debugging concurrent threads and need to verify that there are no race conditions in your code.

=== Inspecting Variables

Any expression can be evaluated in the current context. To evaluate an expression, just type it!

This example shows how you can print the instance_variables defined within the current context:

----------------------------------------------------------------------------
@posts = Post.find(:all)
(rdb:11) instance_variables
["@_response", "@action_name", "@url", "@_session", "@_cookies", "@performed_render", "@_flash", "@template", "@_params", "@before_filter_chain_aborted", "@request_origin", "@_headers", "@performed_redirect", "@_request"]
----------------------------------------------------------------------------

As you may have figured out, all of the variables that you can access from a controller are displayed. This list is dynamically updated as you execute code. For example, run the next line using `next` (you'll learn more about this command later in this guide).

----------------------------------------------------------------------------
(rdb:11) next
Processing PostsController#index (for 127.0.0.1 at 2008-09-04 19:51:34) [GET]
  Session ID: BAh7BiIKZmxhc2hJQzonQWN0aW9uQ29udHJvbGxlcjo6Rmxhc2g6OkZsYXNoSGFzaHsABjoKQHVzZWR7AA==--b16e91b992453a8cc201694d660147bba8b0fd0e
  Parameters: {"action"=>"index", "controller"=>"posts"}
/PathToProject/posts_controller.rb:8
respond_to do |format|
-------------------------------------------------------------------------------

And then ask again for the instance_variables:

----------------------------------------------------------------------------
(rdb:11) instance_variables.include? "@posts"
true
----------------------------------------------------------------------------

Now +@posts+ is a included in the instance variables, because the line defining it was executed.

[TIP]
You can also step into *irb* mode with the command `irb` (of course!). This way an irb session will be started within the context you invoked it. But be warned: this is an experimental feature.

The `var` method is the most convenient way to show variables and their values:

----------------------------------------------------------------------------
var
(rdb:1) v[ar] const <object>            show constants of object
(rdb:1) v[ar] g[lobal]                  show global variables
(rdb:1) v[ar] i[nstance] <object>       show instance variables of object
(rdb:1) v[ar] l[ocal]                   show local variables
----------------------------------------------------------------------------

This is a great way to inspect the values of the current context variables. For example:

----------------------------------------------------------------------------
(rdb:9) var local
  __dbg_verbose_save => false
----------------------------------------------------------------------------

You can also inspect for an object method this way:

----------------------------------------------------------------------------
(rdb:9) var instance Post.new
@attributes = {"updated_at"=>nil, "body"=>nil, "title"=>nil, "published"=>nil, "created_at"...
@attributes_cache = {}
@new_record = true
----------------------------------------------------------------------------

[TIP]
The commands `p` (print) and `pp` (pretty print) can be used to evaluate Ruby expressions and display the value of variables to the console.

You can use also `display` to start watching variables. This is a good way of tracking the values of a variable while the execution goes on.

----------------------------------------------------------------------------
(rdb:1) display @recent_comments
1: @recent_comments =
----------------------------------------------------------------------------

The variables inside the displaying list will be printed with their values after you move in the stack. To stop displaying a variable use `undisplay _n_` where _n_ is the variable number (1 in the last example).

=== Step by Step

Now you should know where you are in the running trace and be able to print the available variables. But lets continue and move on with the application execution.

Use `step` (abbreviated `s`) to continue running your program until the next logical stopping point and return control to ruby-debug.

[TIP]
You can also use `step+ _n_` and `step- _n_` to move forward or backward _n_ steps respectively.

You may also use `next` which is similar to step, but function or method calls that appear within the line of code are executed without stopping. As with step, you may use plus sign to move _n_ steps.

The difference between `next` and `step` is that `step` stops at the next line of code executed, doing just a single step, while `next` moves to the next line without descending inside methods.

For example, consider this block of code with an included +debugger+ statement:

[source, ruby]
----------------------------------------------------------------------------
class Author < ActiveRecord::Base
  has_one :editorial
  has_many :comments

  def find_recent_comments(limit = 10)
    debugger
    @recent_comments ||= comments.find(
      :all,
      :conditions => ["created_at > ?", 1.week.ago],
      :limit => limit
    )
  end
end
----------------------------------------------------------------------------

[TIP]
You can use ruby-debug while using script/console. Just remember to `require "ruby-debug"` before calling the `debugger` method.

----------------------------------------------------------------------------
/PathTo/project $ script/console
Loading development environment (Rails 2.1.0)
>> require "ruby-debug"
=> []
>> author = Author.first
=> #<Author id: 1, first_name: "Bob", last_name: "Smith", created_at: "2008-07-31 12:46:10", updated_at: "2008-07-31 12:46:10">
>> author.find_recent_comments
/PathTo/project/app/models/author.rb:11
)
----------------------------------------------------------------------------

With the code stopped, take a look around:

----------------------------------------------------------------------------
(rdb:1) list
[6, 15] in /PathTo/project/app/models/author.rb
   6      debugger
   7      @recent_comments ||= comments.find(
   8        :all,
   9        :conditions => ["created_at > ?", 1.week.ago],
   10        :limit => limit
=> 11      )
   12    end
   13  end
----------------------------------------------------------------------------

You are at the end of the line, but... was this line executed? You can inspect the instance variables.

----------------------------------------------------------------------------
(rdb:1) var instance
@attributes = {"updated_at"=>"2008-07-31 12:46:10", "id"=>"1", "first_name"=>"Bob", "las...
@attributes_cache = {}
----------------------------------------------------------------------------

+@recent_comments+ hasn't been defined yet, so it's clear that this line hasn't been executed yet. Use the +next+ command to move on in the code:

----------------------------------------------------------------------------
(rdb:1) next
/PathTo/project/app/models/author.rb:12
@recent_comments
(rdb:1) var instance
@attributes = {"updated_at"=>"2008-07-31 12:46:10", "id"=>"1", "first_name"=>"Bob", "las...
@attributes_cache = {}
@comments = []
@recent_comments = []
----------------------------------------------------------------------------

Now you can see that the +@comments+ relationship was loaded and @recent_comments defined because the line was executed.

If you want to go deeper into the stack trace you can move single `steps`, through your calling methods and into Rails code. This is one of the best ways to find bugs in your code, or perhaps in Ruby or Rails.

=== Breakpoints

A breakpoint makes your application stop whenever a certain point in the program is reached. The debugger shell is invoked in that line.

You can add breakpoints dynamically with the command `break` (or just `b`). There are 3 possible ways of adding breakpoints manually:

* `break line`: set breakpoint in the _line_ in the current source file.
* `break file:line [if expression]`: set breakpoint in the _line_ number inside the _file_. If an _expression_ is given it must evaluated to _true_ to fire up the debugger.
* `break class(.|\#)method [if expression]`: set breakpoint in _method_ (. and \# for class and instance method respectively) defined in _class_. The _expression_ works the same way as with file:line.

----------------------------------------------------------------------------
(rdb:5) break 10
Breakpoint 1 file /PathTo/project/vendor/rails/actionpack/lib/action_controller/filters.rb, line 10
----------------------------------------------------------------------------

Use `info breakpoints _n_` or `info break _n_` to list breakpoints. If you supply a number, it lists that breakpoint. Otherwise it lists all breakpoints.

----------------------------------------------------------------------------
(rdb:5) info breakpoints
Num Enb What
  1 y   at filters.rb:10
----------------------------------------------------------------------------

To delete breakpoints: use the command `delete _n_` to remove the breakpoint number _n_. If no number is specified, it deletes all breakpoints that are currently active..

----------------------------------------------------------------------------
(rdb:5) delete 1
(rdb:5) info breakpoints
No breakpoints.
----------------------------------------------------------------------------

You can also enable or disable breakpoints:

* `enable breakpoints`: allow a list _breakpoints_ or all of them if no list is specified, to stop your program. This is the default state when you create a breakpoint.
* `disable breakpoints`: the _breakpoints_ will have no effect on your program.

=== Catching Exceptions

The command `catch exception-name` (or just `cat exception-name`) can be used to intercept an exception of type _exception-name_ when there would otherwise be is no handler for it.

To list all active catchpoints use `catch`.

=== Resuming Execution

There are two ways to resume execution of an application that is stopped in the debugger:

* `continue` [line-specification] (or `c`): resume program execution, at the address where your script last stopped; any breakpoints set at that address are bypassed. The optional argument line-specification allows you to specify a line number to set a one-time breakpoint which is deleted when that breakpoint is reached.
* `finish` [frame-number] (or `fin`): execute until the selected stack frame returns. If no frame number is given, the application run until the currently selected frame returns. The currently selected frame starts out the most-recent frame or 0 if no frame positioning (e.g up, down or frame) has been performed. If a frame number is given it will run until the specified frame returns.

=== Editing

Two commands allow you to open code from the debugger into an editor:

* `edit [file:line]`: edit _file_ using the editor specified by the EDITOR environment variable. A specific _line_ can also be given.
* `tmate _n_` (abbreviated `tm`): open the current file in TextMate. It uses n-th frame if _n_ is specified.

=== Quitting

To exit the debugger, use the `quit` command (abbreviated `q`), or its alias `exit`.

A simple quit tries to terminate all threads in effect. Therefore your server will be stopped and you will have to start it again.

=== Settings

There are some settings that can be configured in ruby-debug to make it easier to debug your code. Here are a few of the available options:

* `set reload`: Reload source code when changed.
* `set autolist`: Execute `list` command on every breakpoint.
* `set listsize _n_`: Set number of source lines to list by default to _n_.
* `set forcestep`: Make sure the `next` and `step` commands always move to a new line

You can see the full list by using `help set`. Use `help set _subcommand_` to learn about a particular +set+ command.

[TIP]
You can include any number of these configuration lines inside a `.rdebugrc` file in your HOME directory. ruby-debug will read this file every time it is loaded. and configure itself accordingly.

Here's a good start for an `.rdebugrc`:

[source, log]
----------------------------------------------------------------------------
set autolist
set forcestep
set listsize 25
----------------------------------------------------------------------------

== References

* link:http://www.datanoise.com/ruby-debug[ruby-debug Homepage]
* link:http://www.sitepoint.com/article/debug-rails-app-ruby-debug/[Article: Debugging a Rails application with ruby-debug]
* link:http://brian.maybeyoureinsane.net/blog/2007/05/07/ruby-debug-basics-screencast/[ruby-debug Basics screencast]
* link:http://railscasts.com/episodes/54-debugging-with-ruby-debug[Ryan Bate's ruby-debug screencast]
* link:http://railscasts.com/episodes/24-the-stack-trace[Ryan Bate's stack trace screencast]
* link:http://railscasts.com/episodes/56-the-logger[Ryan Bate's logger screencast]
* link:http://bashdb.sourceforge.net/ruby-debug.html[Debugging with ruby-debug]
* link:http://cheat.errtheblog.com/s/rdebug/[ruby-debug cheat sheet]
* link:http://wiki.rubyonrails.org/rails/pages/HowtoConfigureLogging[Ruby on Rails Wiki: How to Configure Logging]

== Changelog ==

http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/5[Lighthouse ticket]

* October 19, 2008: Copy editing pass by link:../authors.html#mgunderloy[Mike Gunderloy]
* September 16, 2008: initial version by link:../authors.html#miloops[Emilio Tagua]
